package hb403.geoexplore.controllers;

import hb403.geoexplore.UserStorage.entity.User;
import hb403.geoexplore.UserStorage.repository.UserRepository;
import hb403.geoexplore.comments.CommentRepo.CommentRepository;
import hb403.geoexplore.comments.Entity.CommentEntity;
import hb403.geoexplore.datatype.MarkerTag;
import hb403.geoexplore.datatype.marker.AlertMarker;
import hb403.geoexplore.datatype.marker.EventMarker;
import hb403.geoexplore.datatype.marker.MarkerBase;
import hb403.geoexplore.datatype.marker.ObservationMarker;
import hb403.geoexplore.datatype.marker.ReportMarker;
import hb403.geoexplore.datatype.marker.repository.ImageRepository;
import hb403.geoexplore.datatype.marker.repository.MarkerTagRepository;
import hb403.geoexplore.datatype.marker.repository.ObservationRepository;
import hb403.geoexplore.datatype.request.Location;
import hb403.geoexplore.datatype.request.LocationProximity;
import hb403.geoexplore.datatype.request.LocationRange;
import hb403.geoexplore.datatype.request.Range;
import hb403.geoexplore.util.GeometryUtil;

import java.util.*;

import io.swagger.v3.oas.annotations.Operation;

import org.locationtech.jts.geom.Polygon;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;


@RestController
public class ObservationController {

    @Autowired
    protected ObservationRepository obs_repo;
    @Autowired
    protected MarkerTagRepository tags_repo;
    @Autowired
    protected UserRepository users_repo;
    @Autowired
    protected CommentRepository commentRepository;
    @Autowired
    ImageController imageController;


    // C of Crudl, adds observation to repo
    @Operation(summary = "Add a new observation to the database")
    @PostMapping(path = "geomap/observations")
    public @ResponseBody ObservationMarker saveObs(@RequestBody ObservationMarker observation) {
        if (observation != null) {
            observation.nullifyId();
            observation.enforceLocationIO();
            observation.applyNewTimestamp();
            final ObservationMarker obs = this.obs_repo.save(observation);
            obs.enforceLocationTable();
            return obs;
        }
        return null;
    }

    // R of Crudl gets observation from repo
    @Operation(summary = "Get an observation from the database from its id")
    @GetMapping(path = "geomap/observations/{id}")
    public @ResponseBody ObservationMarker getObs(@PathVariable Long id) {
        if (id != null) {
            try {
                final ObservationMarker o = this.obs_repo.findById(id).get();
                o.enforceLocationTable();
                return o;
            } catch(Exception e) {
                // continue >>> (return null)
            }
        }
        return null;
    }

    // U of Crudl
    @Operation(summary = "Update an observation already in the database by its id")
    @PutMapping(path = "geomap/observations/{id}")
    public @ResponseBody ObservationMarker updateObs(@PathVariable Long id, @RequestBody ObservationMarker observation) {
        if (id != null && observation != null){
            observation.setId(id);
            observation.enforceLocationIO();
            observation.applyUpdatedTimestamp();
            final ObservationMarker obs = this.obs_repo.save(observation);
            obs.enforceLocationTable();
            return obs;
        }
        return null;
    }

    // D of Crudl
    @Operation(summary = "Delete an observation in the database by its id")
    @DeleteMapping(path = "geomap/observations/{id}")
    public @ResponseBody ObservationMarker deleteObs(@PathVariable Long id){
        if (id != null) {
            try {
                final ObservationMarker ref = this.getObs(id);
                if (ref.getImage() != null){ //deletes the image in the file if the observation gets deleted
                    imageController.deleteImage(ref.getImage().getId());
                }
                this.obs_repo.deleteById(id);
                ref.enforceLocationTable();
                return ref;
            } catch(Exception e) {

            }
        }
        return null;
    }

    // L of Crudl
    @Operation(summary = "Get a list of all the observations in the database")
    @GetMapping(path = "geomap/observations")
    public List<ObservationMarker> getAllObs() {
        final List<ObservationMarker> obs = this.obs_repo.findAll();
        for (ObservationMarker o : obs){
            o.enforceLocationTable();
        }
        return obs;
    }


    /** Returns the set of events within the bounds generated by the provided WKT geometry string */
    @Operation(summary = "Get a set of the observations whose locations are bounded by the provided WKT geometry string")
	@GetMapping(path = "geomap/observations/within/poly")
	public @ResponseBody Set<ObservationMarker> getObservationsWithinPoly(@RequestBody String wkt_bounds_geom) {	// takes in 'well known text' for the bounding geometry --> may define special json formats for predefined bounds later
		try {
			final Set<ObservationMarker> bounded = this.obs_repo.findSetWithin( GeometryUtil.getGeometry(wkt_bounds_geom) );
			// System.out.println("Recieved " + bounded.size() + " bounded events");
			for(ObservationMarker o : bounded) {
				o.enforceLocationTable();
			}
			return bounded;
		} catch(Exception e) {
			System.out.println("ObservationController.getObservationsWithinPoly(): Encountered exception! -- " + e.getMessage());
			// continue >>> (return null)
		}
		return null;
	}

    /**  */
    @Operation(summary = "Get a set of the observations whose locations are bounded by the provided location window")
	@PostMapping(path = "geomap/observations/within/rect")
	public @ResponseBody Set<ObservationMarker> getObservationsWithinBounds(@RequestBody Range range) {	// takes in 'well known text' for the bounding geometry --> may define special json formats for predefined bounds later
        if(range == null || range.isInvalid()) return null;
        try {

			final Polygon rect = range.getRect();
			final Set<ObservationMarker> bounded = this.obs_repo.findSetWithin( rect );

			System.out.printf(
				"[OBSERVATIONS RECT SEARCH]: Recieved bounds object: {\n\tmin lat: %f,\n\tmin lon: %f,\n\tmax lat: %f,\n\tmax lat: %f\n}\n" +
				"[OBSERVATIONS RECT SEARCH]: Recieved %d query results.\n" +
				"[OBSERVATIONS RECT SEARCH]: Computed search bounds:\n{\n\tWKT: %s\n}\n",
				range.min_latitude,
				range.min_longitude,
				range.max_latitude,
				range.max_longitude,
				bounded.size(),
				rect.toString()
			);

			// System.out.println("Recieved " + bounded.size() + " bounded events");
			for(ObservationMarker o : bounded) {
				o.enforceLocationTable();
			}
			return bounded;
		} catch(Exception e) {
			System.out.println("ObservationController.getObservationsWithinRect(): Encountered exception! -- " + e.getMessage());
			// continue >>> (return null)
		}
		return null;
	}

    @Operation(summary = "Get the set of observations whose locations are bounded by the provided location window, sorted by distance from the provided location")
	@PostMapping(path = "geomap/observations/within/rect/sorted")
	public @ResponseBody List<ObservationMarker> getProxSortedObservationsWithinRect(@RequestBody LocationRange range) {
		if(range == null || range.isInvalid()) return null;
		try {
			
			final Polygon rect = range.getRect();
			final List<ObservationMarker> bounded = this.obs_repo.findListWithin( rect );

			System.out.printf(
				"[OBSERVATIONS RECT SORTED SEARCH]: Recieved bounds object: {\n\tmin lat: %f,\n\tmin lon: %f,\n\tmax lat: %f,\n\tmax lat: %f,\n\tsrc lat: %f,\n\tsrc lat: %f\n}\n" +
				"[OBSERVATIONS RECT SORTED SEARCH]: Recieved %d query results.\n" +
				"[OBSERVATIONS RECT SORTED SEARCH]: Computed search bounds:\n{\n\tWKT: %s\n}\n",
				range.min_latitude,
				range.min_longitude,
				range.max_latitude,
				range.max_longitude,
				range.src_latitude,
				range.src_longitude,
				bounded.size(),
				rect.toString()
			);

			MarkerBase.sortByProximityAsc(bounded, range.src_latitude, range.src_longitude, true);
			return bounded;

		} catch(Exception e) {
			System.out.println("ObservationController.getProxSortedObservationsWithinRect(): Encountered exception! -- " + e.getMessage());
			// continue >>> (return null)
		}
		return null;
	}

	@Operation(summary = "Get all the observations within the specified proximity (from the specified source) -- results are sorted according to ascending proximity")
	@PostMapping(path = "geomap/observations/within/proximity")
	public @ResponseBody List<ObservationMarker> getObservationsWithinProximitySorted(@RequestBody LocationProximity range) {
		if(range == null || range.isInvalid()) return null;
		try {

            System.out.printf(
				"[OBSERVATIONS PROXIMITY SEARCH]: Recieved range object: {\n\tlat: %f,\n\tlon: %f,\n\trange: %f\n}\n",
				range.latitude,
				range.longitude,
				range.range
			);

			final Polygon[] search_bounds = range.getMinMaxSearchBounds();

            System.out.printf(
				"[OBSERVATIONS PROXIMITY SEARCH]: Computed search bounds (x%d):\n",
				search_bounds.length
			);
			for(Polygon p : search_bounds) {
				System.out.printf(
					"{\n\tWKT: %s\n}\n",
					p.toString()
				);
			}

			List<ObservationMarker> bounded = null;
			for(Polygon p : search_bounds) {
				if(bounded == null) bounded = this.obs_repo.findListWithin(p);
				else bounded.addAll( this.obs_repo.findListWithin(p) );
			}

            System.out.printf(
				"[OBSERVATIONS PROXIMITY SEARCH]: Conducted database bounds search - recieved %d results\n",
				bounded.size()
			);

			if(bounded == null) return null;	// make java shut up about not being initialized blah blah blah
			MarkerBase.sortByProximityAsc(bounded, range.latitude, range.longitude, true);
			
			int
				lower = 0,
				upper = bounded.size();
			for(int i = (upper + lower) / 2; lower < upper && i >= 0 && i < bounded.size(); i = (upper + lower) / 2) {	// binary search
				double dist = bounded.get(i).distanceTo(range.latitude, range.longitude);
				if(dist <= range.range) {
					lower = i + 1;
				} else {
					upper = i;
				}
			}
			return bounded.subList(0, lower);

		} catch(Exception e) {

		}
		return null;
	}

    /** */
	@Operation(summary = "Get the distance to an observation from a specified location (IN MILES)")
	@PostMapping(path = "geomap/observations/{id}/distance")
	public @ResponseBody Double getDistanceToMarkerById(@PathVariable Long id, @RequestBody Location src) {
		if(id != null && src != null && src.isValid()) {
			final ObservationMarker m = this.getObs(id);
			if(m != null) {
				m.enforceLocationTable();
				return GeometryUtil.arcdistanceGlobal(src.latitude, src.longitude, m.getIo_latitude(), m.getIo_longitude());
			}
		}
		return null;
	}



    @Operation(summary = "Add a prexisting tag by its id to a marker by its id")
	@PostMapping(path = "geomap/observations/{id}/tags")
	public @ResponseBody ObservationMarker addTagToMarkerById(@PathVariable Long id, @RequestBody Long tag_id) {
		if(id != null && tag_id != null) {
			try {
				final MarkerTag t = this.tags_repo.findById(tag_id).get();
				final ObservationMarker m = this.obs_repo.findById(id).get();
				if(m.getTags().add(t)) {
                    m.applyUpdatedTimestamp();
					this.obs_repo.save(m);
					return m;
				}
			} catch(Exception e) {

			}
		}
		return null;
	}

    @Operation(summary = "Add a prexisting user by id as a confirmation to a marker by its id")
	@PostMapping(path = "geomap/observations/{id}/confirmations")
	public @ResponseBody ObservationMarker addUserToConfirmedById(@PathVariable Long id, @RequestBody Long user_id) {
		if(id != null && user_id != null) {
			try {
				final ObservationMarker m = this.obs_repo.findById(id).get();
				final User u = this.users_repo.findById(user_id).get();
				if(m.getConfirmed_by().add(u)) {
                    m.applyUpdatedTimestamp();
					this.obs_repo.save(m);
					return m;
				}
			} catch(Exception e) {

			}
		}
		return null;
	}



    /** TODO:
     * - get marker creator (User) by marker id
     * - get marker tags (MarkerTag[]) by marker id
     * - append [NEW] marker tag to list, accessed by marker id
     * - append [EXISTING] marker tag to list, accessed by marker id and tag id
     * - append User to marker "listed users" by marker id and user id
     */


}
